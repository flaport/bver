use std::fs;
use std::process::Command;

use crate::finders::find_repo_root;
use crate::schema::{GitAction, RunPreCommit};

/// Detected pre-commit tool type
enum PreCommitTool {
    Prek,
    PreCommit,
}

/// Check if a command is available
fn command_available(cmd: &str) -> bool {
    Command::new(cmd)
        .arg("--version")
        .output()
        .map(|o| o.status.success())
        .unwrap_or(false)
}

/// Detect which pre-commit tool is available and configured
fn detect_pre_commit_tool() -> Option<PreCommitTool> {
    let repo_root = find_repo_root()?;
    let hook_path = repo_root.join(".git/hooks/pre-commit");

    if !hook_path.exists() {
        return None;
    }

    // Check if the hook is a prek hook
    if let Ok(content) = fs::read_to_string(&hook_path)
        && content.contains("File generated by prek")
        && command_available("prek")
    {
        return Some(PreCommitTool::Prek);
    }

    // Fall back to pre-commit if available
    if command_available("pre-commit") {
        return Some(PreCommitTool::PreCommit);
    }

    None
}

/// Run pre-commit hooks based on config setting
pub fn maybe_run_pre_commit(setting: RunPreCommit) -> Result<(), String> {
    match setting {
        RunPreCommit::Disabled => Ok(()),
        RunPreCommit::Enabled => run_pre_commit(true),
        RunPreCommit::WhenPresent => run_pre_commit(false),
    }
}

fn run_pre_commit(required: bool) -> Result<(), String> {
    let tool = match detect_pre_commit_tool() {
        Some(t) => t,
        None => {
            if required {
                return Err(
                    "pre-commit/prek is not installed but run-pre-commit is enabled".to_string(),
                );
            }
            return Ok(());
        }
    };

    let (cmd, name) = match tool {
        PreCommitTool::Prek => ("prek", "prek"),
        PreCommitTool::PreCommit => ("pre-commit", "pre-commit"),
    };

    println!("Running {} hooks...", name);

    let status = Command::new(cmd)
        .args(["run", "--all-files"])
        .status()
        .map_err(|e| format!("Failed to run {}: {}", name, e))?;

    if status.success() {
        println!("{} hooks passed.", name);
        return Ok(());
    }

    // Failed, run it a second time (it may have auto-fixed files)
    println!("{} hooks failed, running again...", name);

    let status = Command::new(cmd)
        .args(["run", "--all-files"])
        .status()
        .map_err(|e| format!("Failed to run {}: {}", name, e))?;

    if status.success() {
        println!("{} hooks passed on second run.", name);
        Ok(())
    } else {
        Err(format!("{} hooks failed twice, aborting bump", name))
    }
}

/// Run a git command and return the result
fn git(args: &[&str]) -> Result<(), String> {
    println!("Running: git {}", args.join(" "));

    let output = Command::new("git")
        .args(args)
        .output()
        .map_err(|e| format!("Failed to run git: {e}"))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(format!("git {} failed: {}", args[0], stderr.trim()));
    }

    Ok(())
}

/// Run git operations based on config setting
pub fn run_git_actions(
    action: GitAction,
    old_version: &str,
    new_version: &str,
    tag_prefix: &str,
    force: bool,
) -> Result<(), String> {
    let tag_name = format!("{}{}", tag_prefix, new_version);
    match action {
        GitAction::Disabled => Ok(()),
        GitAction::Commit => {
            git_add_all()?;
            git_commit(old_version, new_version)?;
            Ok(())
        }
        GitAction::CommitAndTag => {
            git_add_all()?;
            git_commit(old_version, new_version)?;
            git_tag(&tag_name, new_version, force)?;
            Ok(())
        }
        GitAction::CommitTagAndPush => {
            git_add_all()?;
            git_commit(old_version, new_version)?;
            git_tag(&tag_name, new_version, force)?;
            git_push(force)?;
            git_push_tag(&tag_name, force)?;
            Ok(())
        }
    }
}

fn git_add_all() -> Result<(), String> {
    git(&["add", "--all"])
}

fn git_commit(old_version: &str, new_version: &str) -> Result<(), String> {
    let msg = format!("Bump version from {} to {}", old_version, new_version);
    git(&["commit", "-m", &msg])
}

fn git_tag(tag_name: &str, version: &str, force: bool) -> Result<(), String> {
    let msg = format!("Release {}", version);
    if force {
        git(&["tag", "-a", tag_name, "-m", &msg, "-f"])
    } else {
        git(&["tag", "-a", tag_name, "-m", &msg])
    }
}

fn git_push(force: bool) -> Result<(), String> {
    if force {
        git(&["push", "--force"])
    } else {
        git(&["push"])
    }
}

fn git_push_tag(tag_name: &str, force: bool) -> Result<(), String> {
    if force {
        git(&["push", "origin", tag_name, "--force"])
    } else {
        git(&["push", "origin", tag_name])
    }
}
